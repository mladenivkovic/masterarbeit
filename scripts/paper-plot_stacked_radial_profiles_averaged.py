#!/usr/bin/env python3

#===================================================================
# stack radial profiles generated by plot_radial_profiles_with_std.py
# in combination with get_halostats.sh, plot them, and
# fit NFW profiles on top of it
#
# the script is looking for all available files named
# radial-profiles-data-XXXXX-halo-<int>.pkl
#
# This script needs one command line argument: the output number
# to work with
#
# It looks for subdirectories 'galaxy-512-new-cosmo-100MPC' and
# 'galaxy-512-new-cosmo-69MPC'
#===================================================================

import numpy as np
import matplotlib as mpl
#  mpl.use('Agg')
import matplotlib.pyplot as plt
#  plt.ioff()
from matplotlib.colors import LogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable, axes_size
from scipy.optimize import curve_fit
import pickle
import os

# use LaTeX text
from matplotlib import rc
rc('font', **{'family':'serif',
    'serif':['Computer Modern Roman'],
    'monospace': ['Computer Modern Typewriter']})
rc('text', usetex=True)
rc("figure", **{"dpi":200})



skip_no_mass_threshold = True
use_upper_threshold = True
plot_paper_values = True


#==========================================
def sigma_nfw(r, c, rho0):
#==========================================
    """
    get NFW surface density profile
    assumes r is a numpy array
    following Bartelmann 1996, https://arxiv.org/pdf/astro-ph/9602053.pdf
    """
    Rs = 1./ c
    x = r / Rs

    f = np.zeros(x.shape)
    f[x > 1] = 1 - 2/np.sqrt(x[x>1]**2 - 1) * np.arctan(np.sqrt((x[x>1] - 1)/(x[x>1] + 1)))
    f[x < 1] = 1 - 2/np.sqrt(1 - x[x<1]**2) * np.arctanh(np.sqrt((1 - x[x<1])/(1 + x[x<1])))
    f[x == 1] = 0.

    return  2 * rho0 * Rs / (x**2 - 1) * f


#==========================================
def get_rho0(r, c, sigma):
#==========================================
    """
    given a surfance density sigma, position r [in units of r200],
    and concentration c, find the scale density parameter rho0.

    assume r, c, sigma are a scalar.
    following Bartelmann 1996, https://arxiv.org/pdf/astro-ph/9602053.pdf
    """
    Rs = 1. / c  # divide r200 by itself because you want everything in units of r200
    x = r / Rs

    if x > 1:
        f = 1 - 2/np.sqrt(x**2 - 1) * np.arctan(np.sqrt((x - 1)/(x + 1)))
    elif x < 1:
        f = 1 - 2/np.sqrt(1 - x**2) * np.arctanh(np.sqrt((1 - x)/(1 + x)))
    else:
        f = 0.

    # sigma = 2 * rho0 * Rs / (x**2 - 1) * f
    return  sigma * (x**2 - 1) / (2 * Rs * f)




#================================
def fit_nfw(xdata, ydata, std):
#================================
    """
    Get a fit to NFW surface density profile
    xdata: x values
    ydata: y values
    std: standard deviation of y values

    Returns: 
        (c, rho): Parameters to be fitted
    """
    
    cmax = 20.
    rhoguess = 0.5 * (ydata[0] + ydata[-1])
    opt, cov = curve_fit(
                            sigma_nfw, 
                            xdata, 
                            ydata, 
                            sigma=std, 
                            p0 = [2., rhoguess], 
                            bounds=(0, [cmax, 1e30]), 
                            maxfev=10000000
                        )
    c, rho = opt
    if abs(c/cmax - 1) < 0.01:
        # try again with reduced dataset
        if xdata.shape[0] > 6:
            print("restarting fit")
            if std is None:
                return fit_nfw(xdata[1:-1], ydata[1:-1], std)
            else:
                return fit_nfw(xdata[1:-1], ydata[1:-1], std[1:-1])
    return c, rho




#==========================================
def plot_stacked_radial_profile(outputnr):
#==========================================
    """
    Plots radial profile.
    """


    fig = plt.figure(1, figsize=(4.8, 8))
    colors = ['C0', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7']
    nonorphancolor = 'darkgrey'
    dotalpha = 0.7
    dotsize = 20
    dotshapes = ['o', 's']
    fitalpha = 0.7
    vdBalpha = 0.8
    nonorphanalpha = 0.35
    nonorphanlabel = r"$M_* / M_\odot > 10^{9}$ without orphans"
    special_label =  r"$M_* / M_\odot > 10^{9}$"
    special_color = 'C0'

    ax1 = fig.add_subplot(211)
    ax2 = fig.add_subplot(212)

    #  simlabels = ["\\texttt{G100}, ", "\\texttt{G69}, "]
    #  simlabels = ["\\texttt{G100}, "]





    for sim, srcdir in enumerate(["galaxy-512-new-cosmo-100MPC"]):
    #  for sim, srcdir in enumerate(["galaxy-512-new-cosmo-100MPC", "galaxy-512-new-cosmo-69MPC"]):

        dirlist = os.listdir(os.path.join(os.getcwd(), srcdir))
        filelist = []
        namestart = 'radial-profiles-data-for-stacked-profile-avg-'+outputnr.zfill(5)
        for f in dirlist:
            if f.startswith(namestart) and f.endswith(".pkl"):
                filelist.append(os.path.join(srcdir, f))

        nsamples = len(filelist)

        # read thresholds
        f = open(filelist[0], 'rb')
        thresholds = pickle.load(f)
        threshold_labels = pickle.load(f)
        f.close()

        # open all files and skip to data
        filepointers = [open(fname, "rb") for fname in filelist]


        mass_densities_g = []
        mass_densities_o = []
        number_densities_g = []
        number_densities_o = []

        lin_mass_densities_g = []
        lin_mass_densities_o = []
        lin_number_densities_g = []
        lin_number_densities_o = []

        number_densities_special_g = []
        mass_densities_special_g = []
        mass_densities_special_o = []
        lin_mass_densities_special_g = []
        lin_mass_densities_special_o = []

        m200 = []


        for p in filepointers:
            _ = pickle.load(p) # skip thresholds
            _ = pickle.load(p) # skip threshold labels

            # load averaged profile lists containing arrays for each threshold
            mass_densities_g.append(pickle.load(p))
            mass_densities_o.append(pickle.load(p))
            number_densities_g.append(pickle.load(p))
            number_densities_o.append(pickle.load(p))

            lin_mass_densities_g.append(pickle.load(p))
            lin_mass_densities_o.append(pickle.load(p))
            lin_number_densities_g.append(pickle.load(p))
            lin_number_densities_o.append(pickle.load(p))

            mass_densities_special_g.append(pickle.load(p))
            mass_densities_special_o.append(pickle.load(p))
            lin_mass_densities_special_g.append(pickle.load(p))
            lin_mass_densities_special_o.append(pickle.load(p))
            number_densities_special_g.append(pickle.load(p))

            logbin_centres = pickle.load(p)
            lin_bin_number_centres = pickle.load(p)
            lin_bin_mass_centres = pickle.load(p)

            did_use_upper_threshold = pickle.load(p)
            if did_use_upper_threshold:
                if not use_upper_threshold:
                    print("Used upper threshold in individual files, but not in this script.")
                    print("Fix this!")
                    quit(1)

            did_use_h_correct = pickle.load(p)

            m200.append(pickle.load(p))



        stacked_mass_densities_g = []
        stacked_mass_densities_o = []
        stacked_number_densities_g = []
        stacked_number_densities_o = []

        stacked_lin_mass_densities_g = []
        stacked_lin_mass_densities_o = []
        stacked_lin_number_densities_g = []
        stacked_lin_number_densities_o = []

        stacked_mass_density_fit_g = []
        stacked_mass_density_fit_o = []
        stacked_number_density_fit_g = []
        stacked_number_density_fit_o = []

        stacked_number_densities_special_g = None
        stacked_mass_densities_special_g = None
        stacked_mass_densities_special_o = None
        stacked_lin_mass_densities_special_g = None
        stacked_lin_mass_densities_special_o = None
        stacked_mass_density_fit_special_g = None
        stacked_mass_density_fit_special_o = None



        # Stack data
        #--------------------------------

        for i, t in enumerate(thresholds):
            mg = None
            for halo in mass_densities_g:
                data = halo[i]
                if mg is None:
                    mg = np.copy(data)
                else:
                    mg += data
            stacked_mass_densities_g.append(mg)

        for i, t in enumerate(thresholds):
            mo = None
            for halo in mass_densities_o:
                data = halo[i]
                if mo is None:
                    mo = np.copy(data)
                else:
                    mo += data
            stacked_mass_densities_o.append(mo)

        for i, t in enumerate(thresholds):
            ng = None
            for halo in number_densities_g:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_number_densities_g.append(ng)

        for i, t in enumerate(thresholds):
            no = None
            for halo in number_densities_o:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_number_densities_o.append(no)

        ngs = None
        for data in number_densities_special_g:
            if ngs is None:
                ngs = np.copy(data)
            else:
                ngs += data
        stacked_number_densities_special_g = np.copy(ngs)

        mgs = None
        for data in mass_densities_special_g:
            if mgs is None:
                mgs = np.copy(data)
            else:
                mgs += data
        stacked_mass_densities_special_g = np.copy(mgs)

        mos = None
        for data in mass_densities_special_o:
            if mos is None:
                mos = np.copy(data)
            else:
                mos += data
        stacked_mass_densities_special_o = np.copy(mos)



        # Stack linearly binned data
        #--------------------------------

        for i, t in enumerate(thresholds):
            mg = None
            for halo in lin_mass_densities_g:
                data = halo[i]
                if mg is None:
                    mg = np.copy(data)
                else:
                    mg += data
            stacked_lin_mass_densities_g.append(mg)

        for i, t in enumerate(thresholds):
            mo = None
            for halo in lin_mass_densities_o:
                data = halo[i]
                if mo is None:
                    mo = np.copy(data)
                else:
                    mo += data
            stacked_lin_mass_densities_o.append(mo)

        for i, t in enumerate(thresholds):
            ng = None
            for halo in lin_number_densities_g:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_lin_number_densities_g.append(ng)

        for i, t in enumerate(thresholds):
            no = None
            for halo in lin_number_densities_o:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_lin_number_densities_o.append(no)

        mgs = None
        for data in lin_mass_densities_special_g:
            if mgs is None:
                mgs = np.copy(data)
            else:
                mgs += data
        stacked_lin_mass_densities_special_g = np.copy(mgs)

        mos = None
        for data in lin_mass_densities_special_o:
            if mos is None:
                mos = np.copy(data)
            else:
                mos += data
        stacked_lin_mass_densities_special_o = np.copy(mos)




        # average by the number of haloes/clusters used
        #-------------------------------------------------

        for i, t in enumerate(thresholds):
            stacked_mass_densities_g[i] /= nsamples
            stacked_mass_densities_o[i] /= nsamples
            stacked_number_densities_g[i] /= nsamples
            stacked_number_densities_o[i] /= nsamples

            stacked_lin_mass_densities_g[i] /= nsamples
            stacked_lin_mass_densities_o[i] /= nsamples
            stacked_lin_number_densities_g[i] /= nsamples
            stacked_lin_number_densities_o[i] /= nsamples

        stacked_mass_densities_special_g /= nsamples
        stacked_mass_densities_special_o /= nsamples
        stacked_lin_mass_densities_special_g /= nsamples
        stacked_lin_mass_densities_special_o /= nsamples
        stacked_number_densities_special_g /= nsamples

        # Add M200 median correction
        m200 = np.array(m200)
        median_m200 = np.median(m200)
        median_vdB = 8.6e14
        median_corr = (median_m200/median_vdB)**(1./3)
        print("correction:", median_corr)
        print("my median:", median_m200, m200)
        




        # Get fits
        #--------------------------------

        for i, t in enumerate(thresholds):
            mean = stacked_lin_mass_densities_g[i]
            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_mass_centres[mask]
            std = None
            stacked_mass_density_fit_g.append(fit_nfw(xdata, ydata, std))

        for i, t in enumerate(thresholds):
            mean = stacked_lin_mass_densities_o[i]
            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_mass_centres[mask]
            std = None
            stacked_mass_density_fit_o.append(fit_nfw(xdata, ydata, std))

        for i, t in enumerate(thresholds):
            mean = stacked_lin_number_densities_g[i]
            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_number_centres[mask]
            std = None
            stacked_number_density_fit_g.append(fit_nfw(xdata, ydata, std))

        for i, t in enumerate(thresholds):
            mean = stacked_lin_number_densities_o[i]
            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_number_centres[mask]
            std = None
            stacked_number_density_fit_o.append(fit_nfw(xdata, ydata, std))

        mean = stacked_lin_mass_densities_special_o
        mask = mean > 0
        ydata = mean[mask]
        xdata = lin_bin_mass_centres[mask]
        std = None
        stacked_mass_density_fit_special_o = fit_nfw(xdata, ydata, std)

        mean = stacked_lin_mass_densities_special_g
        mask = mean > 0
        ydata = mean[mask]
        xdata = lin_bin_mass_centres[mask]
        std = None
        stacked_mass_density_fit_special_g = fit_nfw(xdata, ydata, std)



        #----------------------------------------------------
        # Plots, plots, plots!
        #----------------------------------------------------

        # plot number densities
        for i, t in enumerate(thresholds):
            if skip_no_mass_threshold and i == 0: 
                continue

            no = stacked_number_densities_o[i]
            mask = no >= 0
            ax1.scatter(
                        logbin_centres[mask], 
                        no[mask], 
                        marker=dotshapes[i-1], 
                        label=threshold_labels[i], 
                        #  label=simlabels[sim]+threshold_labels[i],
                        c = colors[i+sim],
                        #  c = colors[i+sim*len(simlabels)],
                        alpha = dotalpha, 
                        s = dotsize, 
                        lw=0, 
                    )

            c, rho = stacked_number_density_fit_o[i]
            ax1.loglog(
                        logbin_centres,
                        sigma_nfw(logbin_centres, c, rho),
                        "-",
                        c=colors[i+sim],
                        #  c=colors[i+sim*len(simlabels)],
                        label=threshold_labels[i]+" fit; c={0:.2f}".format(c),
                        #  label=simlabels[sim]+threshold_labels[i]+" fit; c={0:.2f}".format(c),
                        alpha = fitalpha,
                    )

        # Add van der Burg paper profiles
        if plot_paper_values:
            c_paper1 = 1.85
            r_paper1 = 0.1
            sigma_paper1 = 400.
            rho0_paper1 = get_rho0(r_paper1, c_paper1, sigma_paper1)
            #  ax1.loglog(
            #      logbin_centres,
            #      sigma_nfw(logbin_centres, c_paper1, rho0_paper1),
            #      "--",
            #      c = 'b',
            #      label="vdB+15 "+r"$10^9 < M_* / M_\odot < 10^{10}$",
            #      alpha = vdBalpha,
            #      lw=1,
            #      )
            ax1.loglog(
                logbin_centres,
                median_corr * sigma_nfw(logbin_centres, c_paper1, rho0_paper1), 
                "--", 
                c = 'b',
                label="vdB+15 rescaled, "+r"$10^9 < M_* / M_\odot < 10^{10}$",
                alpha = vdBalpha,
                lw=1,
                )
            c_paper2 = 2.31
            r_paper2 = 0.1
            sigma_paper2 = 200.
            rho0_paper2 = get_rho0(r_paper2, c_paper2, sigma_paper2)
            #  ax1.loglog(
            #      logbin_centres,
            #      sigma_nfw(logbin_centres, c_paper2, rho0_paper2),
            #      "--",
            #      c = 'k',
            #      label="vdB+15 "+r"$M_* / M_\odot > 10^{10}$",
            #      alpha = vdBalpha,
            #      lw=1,
            #      )
            ax1.loglog(
                logbin_centres,
                median_corr * sigma_nfw(logbin_centres, c_paper2, rho0_paper2), 
                "--", 
                c = 'k', 
                label="vdB+15 rescaled, "+r"$M_* / M_\odot > 10^{10}$",
                alpha = vdBalpha,
                lw=1,
                )


        # Plot surface mass densities

        mo = stacked_mass_densities_special_o
        mask = mo > 0

        ax2.scatter(
                    logbin_centres[mask],
                    mo[mask],
                    marker=dotshapes[0], 
                    label=special_label,
                    c = special_color, 
                    alpha = dotalpha,
                    s = dotsize,
                    lw=0, 
                )

        c, rho = stacked_mass_density_fit_special_o
        ax2.loglog(
                    logbin_centres,
                    sigma_nfw(logbin_centres, c, rho),
                    "-",
                    c=special_color,
                    #  c=colors[i+sim*len(simlabels)],
                    label=special_label+" fit; c={0:.2f}".format(c),
                    #  label=simlabels[sim]+threshold_labels[i]+" fit; c={0:.2f}".format(c),
                    alpha = fitalpha,
                )

        
        #  ax2.loglog(
        #              logbin_centres,
        #              fact * sigma_nfw(logbin_centres, c, rho),
        #              "-",
        #              c='r',
        #              #  c=colors[i+sim*len(simlabels)],
        #              label=special_label+" corrected fit",
        #              #  label=simlabels[sim]+threshold_labels[i]+" fit; c={0:.2f}".format(c),
        #              alpha = fitalpha,
        #          )



        # Plots without orphans
        #---------------------------

        # plot number densities
        ng = stacked_number_densities_special_g
        mask = ng > 0.
        ax1.loglog(
                    logbin_centres[mask],
                    ng[mask], 
                    label=nonorphanlabel, 
                    c = nonorphancolor, 
                    alpha = nonorphanalpha, 
                )
 
        # Plot surface mass densities
        mg = stacked_mass_densities_special_g
        mask = mg > 0
        ax2.loglog(
                    logbin_centres[mask], 
                    mg[mask], 
                    label=nonorphanlabel, 
                    c = nonorphancolor, 
                    alpha = nonorphanalpha, 
                    )

        if plot_paper_values:
            c_paper3 = 2.03
            r_paper3 = 0.1
            sigma_paper3 = 1e13
            rho0_paper3 = get_rho0(r_paper3, c_paper3, sigma_paper3)
            #  ax2.loglog(
            #      logbin_centres,
            #      sigma_nfw(logbin_centres, c_paper3, rho0_paper3),
            #      "--",
            #      c = 'k',
            #      label="vdB+15",
            #      alpha = vdBalpha,
            #      lw=1,
            #      )
            ax2.loglog(
                logbin_centres,
                median_corr * sigma_nfw(logbin_centres, c_paper3, rho0_paper3), 
                "--", 
                c = 'k', 
                label="vdB+15 rescaled",
                alpha = vdBalpha,
                lw=1,
                )




    for ax in fig.axes:
        #  ax.legend(loc="lower left")
        ax.set_xlabel(r"$r/r_{200c}$")
        ax.grid()

    handles, labels = ax1.get_legend_handles_labels()
    # sort both labels and handles by labels
    labels, handles = zip(*sorted(zip(labels, handles), key=lambda t: t[0]))

    ax1.legend(
            handles, labels, 
            loc="upper center",
            bbox_to_anchor=(0.5, -0.15),
            ncol=2,
            fontsize='x-small',
            )

    handles, labels = ax2.get_legend_handles_labels()
    # sort both labels and handles by labels
    labels, handles = zip(*sorted(zip(labels, handles), key=lambda t: t[0]))
    ax2.legend(
            handles, labels, 
            loc="upper center",
            bbox_to_anchor=(0.5, -0.15),
            ncol=2,
            fontsize='x-small',
            )
    #
    #  ax1.legend(
    #          loc="lower left",
    #          #  ncol=2,
    #          fontsize='x-small',
    #          )
    #
    #  ax2.legend(
    #              loc="lower left",
    #              #  ncol=2,
    #              fontsize='x-small',
    #              )
    #

    ax1.set_title("Surface Number Densities of Stacked Cluster Profiles")
    if did_use_h_correct:
        ax1.set_ylabel(r"$\Sigma_n$ [$r_{200c}\ ^{-2} h^{2}$]")
    else:
        ax1.set_ylabel(r"$\Sigma_n$ [$r_{200c}\ ^{-2}$]")
    ax2.set_title("Surface Mass Densities of Stacked Cluster Profiles")
    if did_use_h_correct:
        ax2.set_ylabel(r"$\Sigma_m$ [$M_\odot$ $r_{200c}\ ^{-2} h^{2}$]")
    else:
        ax2.set_ylabel(r"$\Sigma_m$ [$M_\odot$ $r_{200c}\ ^{-2}$]")

    # save image
    fname = "paper-radial-profiles-stacked-avg-"+outputnr+".pdf"
    plt.tight_layout()
    #  plt.show()
    plt.savefig(fname, dpi=300)
    print("saved figure", fname)
    plt.close()



    return






#===================
def main():
#===================

    from sys import argv

    outputnr = argv[1]

    plot_stacked_radial_profile(outputnr)





#==============================
if __name__ == "__main__":
#==============================
    main()

