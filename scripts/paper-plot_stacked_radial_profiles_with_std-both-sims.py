#!/usr/bin/env python3

#===================================================================
# stack radial profiles generated by plot_radial_profiles_with_std.py
# in combination with get_halostats.sh, plot them, and
# fit NFW profiles on top of it
#
# the script is looking for all available files named
# radial-profiles-data-XXXXX-halo-<int>.pkl
#
# This script needs one command line argument: the output number
# to work with
#
# It looks for subdirectories 'galaxy-512-new-cosmo-100MPC' and
# 'galaxy-512-new-cosmo-69MPC'
#===================================================================

import numpy as np
import matplotlib as mpl
#  mpl.use('Agg')
import matplotlib.pyplot as plt
#  plt.ioff()
from matplotlib.colors import LogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable, axes_size
from scipy.optimize import curve_fit
import pickle
import os

# use LaTeX text
from matplotlib import rc
rc('font', **{'family':'serif',
    'serif':['Computer Modern Roman'],
    'monospace': ['Computer Modern Typewriter']})
rc('text', usetex=True)
rc("figure", **{"dpi":200})



skip_no_mass_threshold = True




#==========================================
def sigma_nfw(r, c, rho0):
#==========================================
    """
    get NFW surface density profile
    assumes r is a numpy array
    following Bartelmann 1996, https://arxiv.org/pdf/astro-ph/9602053.pdf
    """
    Rs = 1./ c
    x = r / Rs

    f = np.zeros(x.shape)
    f[x > 1] = 1 - 2/np.sqrt(x[x>1]**2 - 1) * np.arctan(np.sqrt((x[x>1] - 1)/(x[x>1] + 1)))
    f[x < 1] = 1 - 2/np.sqrt(1 - x[x<1]**2) * np.arctanh(np.sqrt((1 - x[x<1])/(1 + x[x<1])))
    f[x == 1] = 0.

    return  2 * rho0 * Rs / (x**2 - 1) * f



#================================
def fit_nfw(xdata, ydata, std):
#================================
    """
    Get a fit to NFW surface density profile
    xdata: x values
    ydata: y values
    std: standard deviation of y values

    Returns: 
        (c, rho): Parameters to be fitted
    """
    
    cmax = 20.
    rhoguess = 0.5 * (ydata[0] + ydata[-1])
    opt, cov = curve_fit(
                            sigma_nfw, 
                            xdata, 
                            ydata, 
                            sigma=std, 
                            p0 = [2., rhoguess], 
                            bounds=(0, [cmax, 1e30]), 
                            maxfev=10000000
                        )
    c, rho = opt
    if abs(c/cmax - 1) < 0.01:
        # try again with reduced dataset
        if xdata.shape[0] > 6:
            print("restarting fit")
            if std is None:
                return fit_nfw(xdata[1:-1], ydata[1:-1], std)
            else:
                return fit_nfw(xdata[1:-1], ydata[1:-1], std[1:-1])
    return c, rho


#================================================
def get_mean_and_errors(xydata, yzdata, zxdata):
#================================================

    stack = np.vstack((xydata, yzdata, zxdata))
    mean = np.mean(stack, axis=0)
    std = np.std(stack, axis=0)
    return mean, std



#==========================================
def plot_stacked_radial_profile(outputnr):
#==========================================
    """
    Plots radial profile.
    """


    fig = plt.figure(1, figsize=(4.5, 9))
    colors = ['C0', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7']
    nonorphancolor = 'darkgrey'
    alpha = 0.6
    fitalpha = 0.9
    nonorphanalpha = 0.5
    nonorphanlabel = "profiles without orphan galaxies"

    ax1 = fig.add_subplot(211)
    ax1.set_title("Surface Number Densities of Stacked Cluster Profiles")
    ax1.set_ylabel(r"$\Sigma_n$ [$r_{200c}\ ^{-2}$]")

    ax2 = fig.add_subplot(212)
    ax2.set_title("Surface Mass Densities of Stacked Cluster Profiles")
    ax2.set_ylabel(r"$\Sigma_m$ [$M_\odot$ $r_{200c}\ ^{-2}$]")

    simlabels = ["\\texttt{G100}, ", "\\texttt{G69}, "]





    for sim, srcdir in enumerate(["galaxy-512-new-cosmo-100MPC", "galaxy-512-new-cosmo-69MPC"]):

        dirlist = os.listdir(os.path.join(os.getcwd(), srcdir))
        filelist = []
        namestart = 'radial-profiles-data-for-stacked-profile-std-'+outputnr.zfill(5)
        for f in dirlist:
            if f.startswith(namestart) and f.endswith(".pkl"):
                filelist.append(os.path.join(srcdir, f))

        # read thresholds
        f = open(filelist[0], 'rb')
        thresholds = pickle.load(f)
        threshold_labels = pickle.load(f)
        f.close()

        # open all files and skip to data
        filepointers = [open(fname, "rb") for fname in filelist]

        surface_densities_gxy = []
        surface_densities_gyz = []
        surface_densities_gzx = []

        surface_densities_oxy = []
        surface_densities_oyz = []
        surface_densities_ozx = []
        
        number_densities_gxy = []
        number_densities_gyz = []
        number_densities_gzx = []
       
        number_densities_oxy = []
        number_densities_oyz = []
        number_densities_ozx = []

        lin_surface_densities_gxy = []
        lin_surface_densities_gyz = []
        lin_surface_densities_gzx = []

        lin_surface_densities_oxy = []
        lin_surface_densities_oyz = []
        lin_surface_densities_ozx = []

        lin_number_densities_gxy = []
        lin_number_densities_gyz = []
        lin_number_densities_gzx = []

        lin_number_densities_oxy = []
        lin_number_densities_oyz = []
        lin_number_densities_ozx = []



        for p in filepointers:
            _ = pickle.load(p) # skip thresholds
            _ = pickle.load(p) # skip threshold labels

            surface_densities_gxy.append(pickle.load(p))
            surface_densities_gyz.append(pickle.load(p))
            surface_densities_gzx.append(pickle.load(p))

            surface_densities_oxy.append(pickle.load(p))
            surface_densities_oyz.append(pickle.load(p))
            surface_densities_ozx.append(pickle.load(p))

            number_densities_gxy.append(pickle.load(p))
            number_densities_gyz.append(pickle.load(p))
            number_densities_gzx.append(pickle.load(p))
           
            number_densities_oxy.append(pickle.load(p))
            number_densities_oyz.append(pickle.load(p))
            number_densities_ozx.append(pickle.load(p))

            lin_surface_densities_gxy.append(pickle.load(p))
            lin_surface_densities_gyz.append(pickle.load(p))
            lin_surface_densities_gzx.append(pickle.load(p))

            lin_surface_densities_oxy.append(pickle.load(p))
            lin_surface_densities_oyz.append(pickle.load(p))
            lin_surface_densities_ozx.append(pickle.load(p))

            lin_number_densities_gxy.append(pickle.load(p))
            lin_number_densities_gyz.append(pickle.load(p))
            lin_number_densities_gzx.append(pickle.load(p))

            lin_number_densities_oxy.append(pickle.load(p))
            lin_number_densities_oyz.append(pickle.load(p))
            lin_number_densities_ozx.append(pickle.load(p))

            logbin_centres = pickle.load(p)
            lin_bin_number_centres = pickle.load(p)
            lin_bin_mass_centres = pickle.load(p)



        # stack data together
        stacked_surface_densities_gxy = []
        stacked_surface_densities_gyz = []
        stacked_surface_densities_gzx = []
        stacked_surface_densities_gmean = []

        stacked_surface_densities_oxy = []
        stacked_surface_densities_oyz = []
        stacked_surface_densities_ozx = []
        stacked_surface_densities_omean = []

        stacked_number_densities_gxy = []
        stacked_number_densities_gyz = []
        stacked_number_densities_gzx = []
        stacked_number_densities_gmean = []

        stacked_number_densities_oxy = []
        stacked_number_densities_oyz = []
        stacked_number_densities_ozx = []
        stacked_number_densities_omean = []

        stacked_lin_surface_densities_gxy = []
        stacked_lin_surface_densities_gyz = []
        stacked_lin_surface_densities_gzx = []
        stacked_lin_surface_densities_gmean = []
        stacked_lin_surface_densities_gstd = []

        stacked_lin_surface_densities_oxy = []
        stacked_lin_surface_densities_oyz = []
        stacked_lin_surface_densities_ozx = []
        stacked_lin_surface_densities_omean = []
        stacked_lin_surface_densities_ostd = []

        stacked_lin_number_densities_gxy = []
        stacked_lin_number_densities_gyz = []
        stacked_lin_number_densities_gzx = []
        stacked_lin_number_densities_gmean = []
        stacked_lin_number_densities_gstd = []

        stacked_lin_number_densities_oxy = []
        stacked_lin_number_densities_oyz = []
        stacked_lin_number_densities_ozx = []
        stacked_lin_number_densities_omean = []
        stacked_lin_number_densities_ostd = []

        stacked_surface_density_fit_g = []
        stacked_surface_density_fit_o = []
        stacked_number_density_fit_g = []
        stacked_number_density_fit_o = []

        for i, t in enumerate(thresholds):
            sg = None
            for halo in surface_densities_gxy:
                data = halo[i]
                if sg is None:
                    sg = np.copy(data)
                else:
                    sg += data
            stacked_surface_densities_gxy.append(sg)

        for i, t in enumerate(thresholds):
            sg = None
            for halo in surface_densities_gyz:
                data = halo[i]
                if sg is None:
                    sg = np.copy(data)
                else:
                    sg += data
            stacked_surface_densities_gyz.append(sg)

        for i, t in enumerate(thresholds):
            sg = None
            for halo in surface_densities_gzx:
                data = halo[i]
                if sg is None:
                    sg = np.copy(data)
                else:
                    sg += data
            stacked_surface_densities_gzx.append(sg)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_surface_densities_gxy[i], 
                stacked_surface_densities_gyz[i], 
                stacked_surface_densities_gzx[i], 
            )
            stacked_surface_densities_gmean.append(mean)



        for i, t in enumerate(thresholds):
            sg = None
            for halo in lin_surface_densities_gxy:
                data = halo[i]
                if sg is None:
                    sg = np.copy(data)
                else:
                    sg += data
            stacked_lin_surface_densities_gxy.append(sg)

        for i, t in enumerate(thresholds):
            sg = None
            for halo in lin_surface_densities_gyz:
                data = halo[i]
                if sg is None:
                    sg = np.copy(data)
                else:
                    sg += data
            stacked_lin_surface_densities_gyz.append(sg)

        for i, t in enumerate(thresholds):
            sg = None
            for halo in lin_surface_densities_gzx:
                data = halo[i]
                if sg is None:
                    sg = np.copy(data)
                else:
                    sg += data
            stacked_lin_surface_densities_gzx.append(sg)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_lin_surface_densities_gxy[i], 
                stacked_lin_surface_densities_gyz[i], 
                stacked_lin_surface_densities_gzx[i], 
            )
            stacked_lin_surface_densities_gmean.append(mean)
            stacked_lin_surface_densities_gstd.append(std)

            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_number_centres[mask]
            #  std = lin_number_o_std[mask]
            #  stdmin = std[std > 0.].min()
            #  std[std < stdmin] = 1e-3*stdmin
            std = None
            stacked_surface_density_fit_g.append(fit_nfw(xdata, ydata, std))



        for i, t in enumerate(thresholds):
            so = None
            for halo in surface_densities_oxy:
                data = halo[i]
                if so is None:
                    so = np.copy(data)
                else:
                    so += data
            stacked_surface_densities_oxy.append(so)

        for i, t in enumerate(thresholds):
            so = None
            for halo in surface_densities_oyz:
                data = halo[i]
                if so is None:
                    so = np.copy(data)
                else:
                    so += data
            stacked_surface_densities_oyz.append(so)

        for i, t in enumerate(thresholds):
            so = None
            for halo in surface_densities_ozx:
                data = halo[i]
                if so is None:
                    so = np.copy(data)
                else:
                    so += data
            stacked_surface_densities_ozx.append(so)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_surface_densities_oxy[i], 
                stacked_surface_densities_oyz[i], 
                stacked_surface_densities_ozx[i], 
            )
            stacked_surface_densities_omean.append(mean)




        for i, t in enumerate(thresholds):
            so = None
            for halo in lin_surface_densities_oxy:
                data = halo[i]
                if so is None:
                    so = np.copy(data)
                else:
                    so += data
            stacked_lin_surface_densities_oxy.append(so)

        for i, t in enumerate(thresholds):
            so = None
            for halo in lin_surface_densities_oyz:
                data = halo[i]
                if so is None:
                    so = np.copy(data)
                else:
                    so += data
            stacked_lin_surface_densities_oyz.append(so)

        for i, t in enumerate(thresholds):
            so = None
            for halo in lin_surface_densities_ozx:
                data = halo[i]
                if so is None:
                    so = np.copy(data)
                else:
                    so += data
            stacked_lin_surface_densities_ozx.append(so)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_lin_surface_densities_oxy[i], 
                stacked_lin_surface_densities_oyz[i], 
                stacked_lin_surface_densities_ozx[i], 
            )
            stacked_lin_surface_densities_omean.append(mean)
            stacked_lin_surface_densities_ostd.append(std)

            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_number_centres[mask]
            #  std = lin_number_o_std[mask]
            #  stdmin = std[std > 0.].min()
            #  std[std < stdmin] = 1e-3*stdmin
            std = None
            stacked_surface_density_fit_o.append(fit_nfw(xdata, ydata, std))



        for i, t in enumerate(thresholds):
            ng = None
            for halo in number_densities_gxy:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_number_densities_gxy.append(ng)

        for i, t in enumerate(thresholds):
            ng = None
            for halo in number_densities_gyz:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_number_densities_gyz.append(ng)

        for i, t in enumerate(thresholds):
            ng = None
            for halo in number_densities_gzx:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_number_densities_gzx.append(ng)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_number_densities_gxy[i], 
                stacked_number_densities_gyz[i], 
                stacked_number_densities_gzx[i], 
            )
            stacked_number_densities_gmean.append(mean)




        for i, t in enumerate(thresholds):
            ng = None
            for halo in lin_number_densities_gxy:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_lin_number_densities_gxy.append(ng)

        for i, t in enumerate(thresholds):
            ng = None
            for halo in lin_number_densities_gyz:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_lin_number_densities_gyz.append(ng)

        for i, t in enumerate(thresholds):
            ng = None
            for halo in lin_number_densities_gzx:
                data = halo[i]
                if ng is None:
                    ng = np.copy(data)
                else:
                    ng += data
            stacked_lin_number_densities_gzx.append(ng)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_lin_number_densities_gxy[i], 
                stacked_lin_number_densities_gyz[i], 
                stacked_lin_number_densities_gzx[i], 
            )
            stacked_lin_number_densities_gmean.append(mean)
            stacked_lin_number_densities_gstd.append(std)

            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_number_centres[mask]
            #  std = lin_number_o_std[mask]
            #  stdmin = std[std > 0.].min()
            #  std[std < stdmin] = 1e-3*stdmin
            std = None
            stacked_number_density_fit_g.append(fit_nfw(xdata, ydata, std))



        for i, t in enumerate(thresholds):
            no = None
            for halo in number_densities_oxy:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_number_densities_oxy.append(no)

        for i, t in enumerate(thresholds):
            no = None
            for halo in number_densities_oyz:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_number_densities_oyz.append(no)

        for i, t in enumerate(thresholds):
            no = None
            for halo in number_densities_ozx:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_number_densities_ozx.append(no)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_number_densities_oxy[i], 
                stacked_number_densities_oyz[i], 
                stacked_number_densities_ozx[i], 
            )
            stacked_number_densities_omean.append(mean)




        for i, t in enumerate(thresholds):
            no = None
            for halo in lin_number_densities_oxy:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_lin_number_densities_oxy.append(no)

        for i, t in enumerate(thresholds):
            no = None
            for halo in lin_number_densities_oyz:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_lin_number_densities_oyz.append(no)

        for i, t in enumerate(thresholds):
            no = None
            for halo in lin_number_densities_ozx:
                data = halo[i]
                if no is None:
                    no = np.copy(data)
                else:
                    no += data
            stacked_lin_number_densities_ozx.append(no)

        for i, t in enumerate(thresholds):
            mean, std = get_mean_and_errors(
                stacked_lin_number_densities_oxy[i], 
                stacked_lin_number_densities_oyz[i], 
                stacked_lin_number_densities_ozx[i], 
            )
            stacked_lin_number_densities_omean.append(mean)
            stacked_lin_number_densities_ostd.append(std)

            mask = mean > 0
            ydata = mean[mask]
            xdata = lin_bin_number_centres[mask]
            #  std = lin_number_o_std[mask]
            #  stdmin = std[std > 0.].min()
            #  std[std < stdmin] = 1e-3*stdmin
            std = None
            stacked_number_density_fit_o.append(fit_nfw(xdata, ydata, std))





        #----------------------------------------------------
        # Plots, plots, plots!
        #----------------------------------------------------


        # Plot surface mass densities
        for i, t in enumerate(thresholds):
            if skip_no_mass_threshold and i == 0: 
                continue

            surface_density_g = stacked_surface_densities_gmean[i]
            mask = surface_density_g > 0

            if sim == (len(simlabels) - 1) and (i == len(thresholds) - 1):
                nl = nonorphanlabel
            else:
                nl = None

            ax2.loglog(
                        logbin_centres[mask], 
                        surface_density_g[mask], 
                        label=nl, 
                        c = nonorphancolor, 
                        alpha = nonorphanalpha, 
                        )

            #  c, rho = stacked_surface_density_fit_g[i]
            #  ax2.loglog(
            #      logbin_centres,
            #      sigma_nfw(logbin_centres, c, rho),
            #      "-.",
            #      c=colors[i],
            #      label="fit; c={0:.2f}".format(c),
            #      alpha = fitalpha,
            #      )



        # plot number densities
        for i, t in enumerate(thresholds):
            if skip_no_mass_threshold and i == 0: 
                continue

            number_density_g = stacked_number_densities_gmean[i]
            mask = number_density_g >= 0

            if sim == (len(simlabels) - 1) and (i == len(thresholds) - 1):
                nl = nonorphanlabel
            else:
                nl = None

            ax1.loglog(
                logbin_centres[mask], 
                number_density_g[mask], 
                label=nl, 
                c = nonorphancolor, 
                alpha = nonorphanalpha, 
                )

            #  c, rho = stacked_number_density_fit_g[i]
            #  ax1.loglog(
            #      logbin_centres,
            #      sigma_nfw(logbin_centres, c, rho),
            #      "-.",
            #      c=colors[i],
            #      label="fit; c={0:.2f}".format(c),
            #      alpha = fitalpha,
            #      )

        # plot number densities
        for i, t in enumerate(thresholds):
            if skip_no_mass_threshold and i == 0: 
                continue

            number_density_o = stacked_number_densities_omean[i]
            mask = number_density_o >= 0
            ax1.loglog(
                logbin_centres[mask], 
                number_density_o[mask], 
                label=simlabels[sim]+threshold_labels[i], 
                c = colors[i+sim*len(simlabels)],
                alpha = alpha, 
                )

            c, rho = stacked_number_density_fit_o[i]
            ax1.loglog(
                logbin_centres,
                sigma_nfw(logbin_centres, c, rho),
                "-.",
                c=colors[i+sim*len(simlabels)],
                label=simlabels[sim]+threshold_labels[i]+" fit; c={0:.2f}".format(c),
                alpha = fitalpha,
                )


        # Plot surface mass densities
        for i, t in enumerate(thresholds):
            if skip_no_mass_threshold and i == 0: 
                continue

            surface_density_o = stacked_surface_densities_omean[i]
            mask = surface_density_o > 0

            ax2.loglog(
                logbin_centres[mask], 
                surface_density_o[mask], 
                label=simlabels[sim]+threshold_labels[i], 
                c = colors[i+sim*len(simlabels)], 
                alpha = alpha, 
                )

            c, rho = stacked_surface_density_fit_o[i]
            ax2.loglog(
                logbin_centres,
                sigma_nfw(logbin_centres, c, rho),
                "-.",
                c=colors[i+sim*len(simlabels)],
                label=simlabels[sim]+threshold_labels[i]+" fit; c={0:.2f}".format(c),
                alpha = fitalpha,
                )



    for ax in fig.axes:
        #  ax.legend(loc="lower left")
        ax.set_xlabel(r"$r/r_{200c}$")
        ax.grid()

    ax1.legend(
            loc="upper center", 
            bbox_to_anchor=(0.5, -0.15), 
            ncol=2, 
            fontsize='x-small', 
            )

    ax2.legend(
                loc="upper center", 
                bbox_to_anchor=(0.5, -0.15), 
                ncol=2, 
                fontsize='x-small', 
                )


    # save image
    fname = "paper-radial-profiles-stacked-std-both-sims-"+outputnr+".pdf"
    plt.tight_layout()
    #  plt.show()
    plt.savefig(fname, dpi=300)
    print("saved figure", fname)
    plt.close()



    return






#===================
def main():
#===================

    from sys import argv

    outputnr = argv[1]

    plot_stacked_radial_profile(outputnr)





#==============================
if __name__ == "__main__":
#==============================
    main()

